import { FileSystemBackend } from '../../types';
const WORKER_SCRIPT = `self.onmessage = async (e) => { const { id, path, data } = e.data; try { const root = await navigator.storage.getDirectory(); const parts = path.split('/').filter(p => p.length > 0); const fileName = parts.pop(); let current = root; for (const part of parts) { current = await current.getDirectoryHandle(part, { create: true }); } const fileHandle = await current.getFileHandle(fileName, { create: true }); const accessHandle = await fileHandle.createSyncAccessHandle(); const encoder = new TextEncoder(); const buffer = encoder.encode(data); accessHandle.truncate(0); accessHandle.write(buffer, { at: 0 }); accessHandle.flush(); accessHandle.close(); self.postMessage({ id, success: true }); } catch (err) { self.postMessage({ id, success: false, error: err.toString() }); } };`;
export class OPFSBackend implements FileSystemBackend {
  private root: FileSystemDirectoryHandle | null = null;
  private vaultName = 'SECURE_VAULT.sys';
  private worker: Worker | null = null;
  private workerRequests = new Map<number, (res: any) => void>();
  private reqId = 0;
  async mount(): Promise<void> { if (!('storage' in navigator)) throw new Error('OPFS not supported'); this.root = await navigator.storage.getDirectory(); }
  async requestPersistence(): Promise<boolean> { return navigator.storage && navigator.storage.persist ? await navigator.storage.persist() : false; }
  private getWorker(): Worker { if (!this.worker) { const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' }); this.worker = new Worker(URL.createObjectURL(blob)); this.worker.onmessage = (e) => { const resolver = this.workerRequests.get(e.data.id); if (resolver) { resolver(e.data); this.workerRequests.delete(e.data.id); } }; } return this.worker; }
  private async writeWithWorker(path: string, data: string): Promise<void> { return new Promise((resolve, reject) => { const id = this.reqId++; this.workerRequests.set(id, (res) => res.success ? resolve() : reject(res.error)); this.getWorker().postMessage({ id, path, data }); }); }
  async isLocked(): Promise<boolean> { if (!this.root) await this.mount(); try { const v = await this.root!.getDirectoryHandle(this.vaultName); await v.getFileHandle('.vault_lock'); return true; } catch { return false; } }
  async createLock(password: string): Promise<boolean> { if (!this.root) await this.mount(); const encoder = new TextEncoder(); const hash = await crypto.subtle.digest('SHA-256', encoder.encode(password)); const hashHex = Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2,'0')).join(''); const data = JSON.stringify({ hash: hashHex }); await this.writeWithWorker(`${this.vaultName}/.vault_lock`, data); return true; }
  async unlock(password: string): Promise<boolean> { if (!this.root) await this.mount(); try { const v = await this.root!.getDirectoryHandle(this.vaultName); const f = await v.getFileHandle('.vault_lock'); const t = await (await f.getFile()).text(); const h = JSON.parse(t).hash; const encoder = new TextEncoder(); const hash = await crypto.subtle.digest('SHA-256', encoder.encode(password)); return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2,'0')).join('') === h; } catch { return false; } }
  private async getHandle(path: string, create = false, type = 'file'): Promise<FileSystemHandle | null> { if (!this.root) await this.mount(); const parts = path.split('/').filter(p => p.length > 0); let current = await this.root!.getDirectoryHandle(this.vaultName, { create: false }); for (let i = 0; i < parts.length; i++) { const part = parts[i]; if (i === parts.length - 1) return type === 'file' ? await current.getFileHandle(part, { create }) : await current.getDirectoryHandle(part, { create }); else current = await current.getDirectoryHandle(part, { create }); } return current; }
  async exists(path: string): Promise<boolean> { try { return !!(await this.getHandle(path)); } catch { return false; } }
  async ls(path: string): Promise<string[]> { if (!this.root) await this.mount(); const h = path === '/' ? await this.root!.getDirectoryHandle(this.vaultName) : await this.getHandle(path, false, 'dir') as FileSystemDirectoryHandle; const r: string[] = []; for await (const [n, e] of (h as any).entries()) { if (n !== '.vault_lock') r.push(n + (e.kind === 'directory' ? '/' : '')); } return r; }
  async cat(path: string): Promise<string> { const h = await this.getHandle(path) as FileSystemFileHandle; return await (await h.getFile()).text(); }
  async write(path: string, data: string): Promise<void> { await this.writeWithWorker(`${this.vaultName}/${path.startsWith('/')?path.slice(1):path}`, data); }
  async mkdir(path: string): Promise<void> { await this.getHandle(path, true, 'dir'); }
  async rm(path: string): Promise<void> { const p = path.split('/'); const n = p.pop(); let d = await this.root!.getDirectoryHandle(this.vaultName); for (const part of p) if (part) d = await d.getDirectoryHandle(part); await d.removeEntry(n!, { recursive: true }); }
}